
== a + b

The values of Input a and b are added, creating a simple mixer. 

For example, you might have LFO1 assigned for the Src2 parameter on a layer's PITCH page, and a FUN assigned for the DptCtl parameter. On the FUN page, if you set Input a to a value of MWheel, and Input b to a value of MPress, then this equation will let you modulate the depth of the LFO's pitch modulation with your MIDI controller's Mod Wheel or with mono pressure. You could set a fixed initial depth with the Mod Wheel and alter it further with mono pressure. In this case the output signal would pin at +1 or -1 fairly quickly.

== a - b
This operates similarly to the previous equation, but the value of Input b is subtracted from the value of Input a. This equation will reverse the normal effect of the control source assigned to Input b. For example, if Input a is off, and Input b is assigned to a unipolar control source like MWheel, then the Mod Wheel will generate a control signal of -1 when fully down, and 0 when fully up.

== (a + b) / 2
The values of Inputs a and b are added, and the sum is divided by 2. This gives you the same kind of control as the previous two equations, but the output signal will reach +1 or -1 half as often as with the equation a + b.

== a / 2 + b
The value of Input a is divided by 2, and the result is added to the value of Input b. Input a has half the effect of Input b.

== a / 4 + b / 2
The value of Input a is divided by 4, and the value of Input b is divided by 2. The two results are added to give the output value. Input a has half the effect of Input b, and the total result has half 
the effect of the previous equation.

== (a + 2b) / 3
The value of Input b is multiplied by 2, and the result is added to the value of Input a. This sum is then divided by 3. Input a has half the effect of Input b, and the total result has somewhat more effect than the previous equation, but less effect than a + b.

== a  *  b
The values of Inputs a and b are multiplied. If you like using Src2 and DptCtl, this equation can be used to create a similar type of control source (it's equivalent to the Src2/DptCtl pair with the 
MinDpt parameter set to 0)

== -a  *  b
The value of Input a is multiplied by -1, then multiplied by the value of Input b. This will reverse 
the normal effect of the control source assigned to Input a. This equation also produces an effect 
like that of Src2 and DptCtl with the MinDpt parameter set to 0.

== a * 10 ^ b
The actual equation is:  a x ( 10 ^(2 x b)^ /100). 

This is an exponential curve. 10 is raised to the (2 x b) power, then divided by 100. This result is then multiplied by a. Another way to express this is as follows: a change of 1 in the value of Input b 
results in a hundredfold change in the output value. 
Here are a few possible output values:


[cols="1,1",options="header"]
|===
|Input Values |Output Value

|a = +1, b = +1
|+1
|a = +1, b = 0 
|0.01
|a = +1, b = -1 
|.0001
|a = 0, b = +1 
|0
|a = 0, b = 0 
|0
|a = 0, b = -+1 
|0
|a = -1, b = +1 
|-1
|a = -1, b = 0 
|-0.01
|a = -1, b = -1 
|-.0001
|===


== | a + b |

The values of Inputs a and b are added, and the absolute value of the sum is taken. If the sum is 
negative, it is multiplied by -1. This makes the FUN a unipolar control source.

== | a - b |

The value of Input b is subtracted from the value of Input a, and the absolute value is taken. If 
the difference is negative, it is multiplied by -1. This also makes the FUN unipolar.

== min (a, b)

The values of Inputs a and b are compared, and the smaller value becomes the output value. 
This can be used to limit the value range of a control source. If, for example the value of the control source assigned to Input b is left at +.5, then when the value of the control source
assigned to Input a is between -1 and +.5, its value will be used. As soon as its value exceeds +.5,
the value of Input b is used.

== max (a, b)

This is the opposite of the previous equation. The values of Inputs a and b are compared, and the larger value becomes the output value.

== Quantize b to a

This turns the control source assigned to Input b into a stepped control source. Instead of smooth transitions from minimum to maximum, it will jump from minimum to maximum in some number of equal steps. The number of steps is determined by the value of Input a. The 
normal real-time application of this is to set a stationary value for Input a to set the number of 
steps in the effect. Then use the control source assigned to Input b as a real-time control to 
induce the stepped effect. Changing the value of Input a in real time will produce an extraneous 
(but possibly useful) effect.

As an example, consider the FUN we set up at the beginning of the previous section:  the Mod 
Wheel was assigned as Input a, and the data slider as Input b. The FUN was assigned as Src1 on 
the PITCH page, and the depth of Src1 was set to 1200 cents. If you push the Mod Wheel all the 
way up, the value of Input a will be +1. This will set the number of steps at 8, since the data 
slider sends a unipolar control signal. With your MIDI controller's data slider at minimum, play 
and sustain a note. Then move the data slider slowly up. The pitch of the note will jump up an 
octave in 8 steps as you move the data slider all the way up.
If the value of Input a is negative, it's multiplied by -1, so its value always falls within the ranges 
above. When Input b is bipolar and the resulting number of steps is an odd number, the steps 
are centered around a value of 0 --that is, the center step is equivalent to no effect from Input b. 
When the number of steps is even, a value of zero is not included in the steps. This is also true 
for the values marked by an asterisk when Input b is unipolar.

== lowpass (f = a, b)

This equation might be called a lag equation. Its effect is to introduce a delay in the K2600's 
response to changes in the value of Input b. It works by filtering (reducing) higher values of 
Input b. The value of Input a determines the degree to which the values of Input b are filtered. 
Low values for Input a will induce a long lag when the value of Input b changes. High values 
will shorten the lag. When Input b remains constant at a high level, low values of Input a will 
cause the FUN to sweep up slowly from 0 to the value of Input b. Higher values for Input a will 
cause the FUN to sweep more rapidly.
The four graphs below show the effect of different values for Input a on the change of Input b. In 
each graph, the value of Input b jumps from 0 to +1. In graph 1, the value of Input a is +1. Each 
successive graph represents the same change in the value of Input b, at successively lower 
values for Input a.
This equation works as intended only when the value of Input a is 0 or positive. Negative values 
for Input a will result in a much less predictable response than positive values. You might like 
the effect, but it won't be anything like what we've just described.

== hipass (f = a, b)

With this equation the low values of Input b are filtered according to the value of Input a. This 
causes somewhat different results compared with the lowpass equation above. At low values for 
Input a, low values for Input b will have little effect, while high values for Input b will cause the 
FUN to quickly reach full effect then slowly sweep down to its starting level. At high values for 
Input a, a rapid change in the value of Input b will have little effect. At low values for Input a, 
rapid changes in the value of Input b will cause the FUN to respond quickly to the change, then 
slowly fade back to minimum effect. Listening to the effects at different values for each input 
will give you the best understanding.
The four graphs below show the effect of different values for Input a on the change of Input b. In 
each graph, the value of Input b drops from +1 to 0. In graph 1, the value of Input a is +1. Each 
successive graph represents the same change in the value of Input b, at successively lower 
values for Input a.


== b / (1 - a)
This is another weighted difference equation similar to the first six. The value of Input a is 
subtracted from 1. The value of Input b is then divided by the difference. You'll get considerably 
different results for different input values of a and b.

== a(b-y)

Think of this equation as reading "y is replaced by the result of the function a(b-y)." The value of 
y indicates the value of the FUN's output signal. Every 20 milliseconds, the K2600 takes the 
current value of y, runs the equation, calculates a new value of y, and inserts the new value into 
the equation. Consequently the value of y will change every twenty milliseconds. HereÕs an 
example. When you play a note, the K2600 starts running the FUN. The Þrst value for y is 
always 0. We'll assume the value of Input a is +.5, and the value of Input b is +1. The first time 
the K2600 evaluates the FUN, the result of the equation is .5 x (+1 - 0), or .5. So the FUN's output 
value after the first evaluation is .5. This becomes the new value for y, and when the K2600 does 
its next evaluation of the FUN, the equation becomes .5 x (+1 - .5), or .25. The resulting output 
value is .25, which becomes the new value for y. For the next evaluation, the equation is .5 x (+1- 
.25), or .375.

== (a + b)^2

The values of Inputs a and b are added, and the result is squared (multiplied by itself). This will 
change the linear curve of a unipolar control signal into a curve that's lower at its midpoint (by a 
factor of 2). Bipolar control signals will generate curves that are high at both ends, and 0 in the 
middle.

=== sin (a + b), cos (a + b), tri (a + b)

These equations are intended to be used with inputs that are sawtooth waves -- for example, 
Input a might be LFO1 with its shape set as a sawtooth. Each equation will map a sawtooth-
shaped input into a sine-, cosine-, or triangle-shaped output. Other input waveform shapes will 
result in outputs with more complex waveform shapes.
Other ways to get sawtooth shapes as inputs to these FUNs are to use other FUNs as the inputs, 
with their equations set as any of the ramp equations described later in this section (see the note 
on page 17-18 about the evaluation order of the FUNs). You could also use LFOph1 or LFOph2 
as inputs. The first three graphs below show the result of these functions when Input a is a rising 
sawtooth wave, and the value of Input b is 0. The fourth shows the result of the sin (f=a + b) 
equation when the value of Input b is 0 and Input a is a sine wave.

== Warp FUN Equations
The next five equations all behave similarly, and are intended to be used as follows: the value of 
Input a is the controlling value, and normally remains constant, although it doesn't have to. The 
value of Input b is expected to change over time; Input b might be an LFO, for example. The 
value for Input a affects how the FUN calculates its output value while the value of Input b 
changes.

=== warp1(a, b)
We call this the Vari-slopeª equation. The value of Input a controls the mapping of values for 
Input b. If Input b is a sawtooth wave, different values for Input a will change it into a triangle 
wave. If Input b is a more complicated waveform, the output waveform is also more 
complicated.